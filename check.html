<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Private Messenger â€” Model Chat</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#041021; --panel:#071427; --muted:#9aa2b2;
    --accent1:#ff6f2d; --accent2:#ff4b98; --danger:#e02323;
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,Arial}
  body{margin:0;background:linear-gradient(180deg,var(--bg),#031226);color:#e9f7ff;height:100vh;overflow:hidden}
  /* layout */
  .app {
    height:100vh;
    display:grid;
    grid-template-columns:320px 1fr;
    gap:12px;
    padding:12px;
    align-items:stretch;
  }
  @media(max-width:900px){ .app{ grid-template-columns: 1fr; padding:8px; } }

  /* sidebar */
  .sidebar {
    background:linear-gradient(180deg,#071a2b,#06101b);
    border-radius:12px;
    padding:12px;
    display:flex;
    flex-direction:column;
    gap:10px;
    min-height:0; /* for flexbox scrolling */
  }
  .sidebar header{display:flex;align-items:center;justify-content:space-between}
  .sidebar .controls{display:flex;gap:8px}
  .conversations{overflow:auto;flex:1}
  .conv {display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:8px;cursor:pointer}
  .conv:hover{background:rgba(255,255,255,0.02)}
  .meta{display:flex;gap:10px;align-items:center}
  .avatar{width:44px;height:44px;border-radius:8px;background:linear-gradient(135deg,var(--accent1),var(--accent2));display:flex;align-items:center;justify-content:center;font-weight:700}
  .name{font-weight:700}
  .last{font-size:12px;color:var(--muted)}
  .badge{background:var(--danger);color:white;padding:6px 8px;border-radius:999px;font-weight:700;font-size:12px}

  /* center chat */
  .chat {
    background:linear-gradient(180deg,#071427,#061025);
    border-radius:12px;
    padding:12px;
    display:flex;
    flex-direction:column;
    min-height:0;
  }
  .chat header{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
  .chat .subtitle{font-size:13px;color:var(--muted)}
  .messages{flex:1;overflow:auto;padding:8px;display:flex;flex-direction:column;gap:10px}
  .msg{max-width:78%;padding:10px 12px;border-radius:12px;word-break:break-word}
  .msg.self{align-self:flex-end;background:linear-gradient(45deg,var(--accent1),var(--accent2));color:#06111a}
  .msg.other{align-self:flex-start;background:rgba(255,255,255,0.04);color:#eaf2ff}
  .msg small{display:block;font-size:11px;color:var(--muted);margin-top:6px}
  .compose{display:flex;gap:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.03);align-items:center}
  .compose input[type="text"]{flex:1;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
  .btn{background:linear-gradient(45deg,var(--accent1),var(--accent2));padding:10px 12px;border-radius:10px;border:none;color:white;cursor:pointer;font-weight:700}
  .ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:inherit;cursor:pointer}

  /* top header area */
  .topbar{display:flex;align-items:center;justify-content:space-between;padding:8px 12px}
  .topbar .logo{display:flex;gap:10px;align-items:center}
  .topbar .logo .mark{width:40px;height:40px;border-radius:8px;background:linear-gradient(135deg,var(--accent1),var(--accent2));display:flex;align-items:center;justify-content:center;font-weight:800}
  .topbar .actions{display:flex;gap:8px;align-items:center}

  /* login modal */
  .modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:60}
  .modal.open{display:flex}
  .card{background:#07101a;padding:18px;border-radius:10px;color:#e6eef6;min-width:280px;max-width:420px}
  .input{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit;margin-top:8px}

  /* floating chat open button + unread badge on mobile */
  .openChatBtn{position:fixed;right:18px;bottom:18px;width:64px;height:64px;border-radius:999px;background:linear-gradient(45deg,var(--accent1),var(--accent2));display:flex;align-items:center;justify-content:center;font-size:26px;z-index:70;box-shadow:0 12px 30px rgba(0,0,0,0.45);cursor:pointer}
  .openChatBadge{position:absolute;top:-6px;right:-6px;background:var(--danger);color:white;padding:6px 8px;border-radius:999px;font-weight:700;font-size:12px;display:none}

  /* responsive tweaks */
  @media (max-width:900px){
    .sidebar{order:2;display:none} /* collapsed by default on mobile, toggled via JS */
    .sidebar.open{display:block;position:absolute;left:8px;right:8px;top:70px;bottom:8px;z-index:80}
    .chat{order:1}
    .topbar .actions .desktop-only{display:none}
  }

  /* small scrollbars */
  .messages::-webkit-scrollbar{width:8px}
  .messages::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.04);border-radius:8px}
</style>
</head>
<body>

<!-- Topbar -->
<div class="topbar" style="padding:12px 18px;background:transparent">
  <div class="logo">
    <div class="mark">MG</div>
    <div>
      <div style="font-weight:800">ModelChat</div>
      <div style="font-size:13px;color:var(--muted)">Private chat â€” only you and model see this.</div>
    </div>
  </div>
  <div class="actions">
    <button id="toggleSidebar" class="ghost desktop-only">â˜°</button>
    <div id="userInfo" style="font-size:13px;color:var(--muted)">Not signed in</div>
    <button id="openLogin" class="ghost">Login</button>
  </div>
</div>

<!-- Main app -->
<div class="app" id="appRoot" aria-hidden="true" style="display:none">

  <!-- Sidebar: conversations (admin) -->
  <aside class="sidebar" id="sidebar">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div style="font-weight:800">Inbox</div>
      <div style="font-size:13px;color:var(--muted)">Unread on top</div>
    </div>
    <div class="conversations" id="conversationsList" role="list"></div>
  </aside>

  <!-- Chat area -->
  <main class="chat" id="chatArea" aria-live="polite">
    <header>
      <div>
        <div id="chatTitle" style="font-weight:800">Welcome</div>
        <div class="subtitle" id="chatSubtitle">Only you and model see this.</div>
      </div>
      <div>
        <button id="signOutBtn" class="ghost" style="display:none">Sign out</button>
      </div>
    </header>

    <div class="messages" id="messages"></div>

    <div class="compose">
      <label for="fileInput" class="ghost">ðŸ“Ž</label>
      <input id="fileInput" type="file" accept="image/*,video/*" style="display:none"/>
      <input id="textInput" type="text" placeholder="Write a message..." autocomplete="off"/>
      <button id="sendBtn" class="btn">Send</button>
    </div>
  </main>

</div>

<!-- Floating open chat button (mobile friendly) -->
<div class="openChatBtn" id="openChatBtn">
  ðŸ’¬
  <div class="openChatBadge" id="openChatBadge">0</div>
</div>

<!-- Login modal -->
<div class="modal" id="loginModal" aria-hidden="true">
  <div class="card">
    <div style="font-weight:800;font-size:18px">Sign in</div>
    <div style="font-size:13px;color:var(--muted);margin-top:6px">Sign in with email/password. Firestore decides who is admin.</div>
    <input id="emailInput" class="input" placeholder="Email"/>
    <input id="passInput" class="input" type="password" placeholder="Password"/>
    <label style="display:flex;align-items:center;gap:8px;margin-top:8px"><input type="checkbox" id="rememberMe"/> Remember me</label>
    <div style="display:flex;gap:8px;margin-top:10px">
      <button id="loginBtn" class="btn">Sign in</button>
      <button id="loginClose" class="ghost">Close</button>
    </div>
    <div style="margin-top:10px;font-size:13px;color:var(--muted)">If a user should be an admin, set `users/{uid}.role = "admin"` in Firestore for that uid.</div>
  </div>
</div>

<!-- Firebase libs -->
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-storage-compat.js"></script>

<!-- External config (must exist in same folder) -->
<script src="configuration.js"></script>

<script>
/*
  Messenger-style private chat
  - External config: configuration.js must export window.FIREBASE_CONFIG
  - Firestore structure:
    users/{uid} { role: "admin" | "user", email?: string }
    conversations/{uid} { lastMessage, lastTimestamp, unreadFromUser, unreadFromAdmin, displayName? }
    messages/{uid}/items/{msg} { from, fromName, text, mediaUrl, mediaType, timestamp }
*/

(async function(){
  if(!window.FIREBASE_CONFIG){
    document.body.innerHTML = '<div style="padding:20px;color:white">Missing configuration.js â€” set window.FIREBASE_CONFIG</div>';
    return;
  }

  // initialize firebase
  firebase.initializeApp(window.FIREBASE_CONFIG);
  const auth = firebase.auth();
  const db = firebase.firestore();
  const storage = firebase.storage();
  const { serverTimestamp, FieldValue } = firebase.firestore;

  // DOM refs
  const appRoot = document.getElementById('appRoot');
  const sidebar = document.getElementById('sidebar');
  const conversationsList = document.getElementById('conversationsList');
  const messagesEl = document.getElementById('messages');
  const chatTitle = document.getElementById('chatTitle');
  const chatSubtitle = document.getElementById('chatSubtitle');
  const signOutBtn = document.getElementById('signOutBtn');
  const openChatBtn = document.getElementById('openChatBtn');
  const openChatBadge = document.getElementById('openChatBadge');
  const topUserInfo = document.getElementById('userInfo');
  const toggleSidebar = document.getElementById('toggleSidebar');

  const fileInput = document.getElementById('fileInput');
  const textInput = document.getElementById('textInput');
  const sendBtn = document.getElementById('sendBtn');

  const loginModal = document.getElementById('loginModal');
  const loginBtn = document.getElementById('loginBtn');
  const loginClose = document.getElementById('loginClose');
  const emailInput = document.getElementById('emailInput');
  const passInput = document.getElementById('passInput');
  const rememberMe = document.getElementById('rememberMe');
  const openLogin = document.getElementById('openLogin');

  // state
  let me = null;
  let myRole = 'guest'; // 'admin' | 'user' | 'guest'
  let currentConversationId = null; // uid of open conversation (for admin) or user's own uid (for user)
  let convsUnsub = null;
  let msgsUnsub = null;
  let myConvUnsub = null;

  // helpers
  function el(tag, props={}, ...kids){ const e=document.createElement(tag); for(const k in props){ if(k in e) e[k]=props[k]; else e.setAttribute(k, props[k]); } kids.forEach(k=>{ if(k==null) return; if(k instanceof Node) e.appendChild(k); else e.appendChild(document.createTextNode(k)); }); return e; }
  function openModal(){ loginModal.classList.add('open'); loginModal.style.display='flex'; }
  function closeModal(){ loginModal.classList.remove('open'); loginModal.style.display='none'; }
  function showApp(){ appRoot.style.display='grid'; appRoot.setAttribute('aria-hidden','false'); }
  function hideApp(){ appRoot.style.display='none'; appRoot.setAttribute('aria-hidden','true'); }
  function fmtTime(ts){ if(!ts) return ''; try{ return ts.toDate ? ts.toDate().toLocaleString() : new Date(ts).toLocaleString(); } catch(e){ return ''; } }

  // persistence helper
  async function setPersistence(remember){ try{ await auth.setPersistence(remember ? firebase.auth.Auth.Persistence.LOCAL : firebase.auth.Auth.Persistence.SESSION); } catch(e){ console.warn('persistence error', e); } }

  // open/close sidebar on mobile
  toggleSidebar.addEventListener('click', ()=> {
    sidebar.classList.toggle('open');
  });

  // Open chat button behavior
  openChatBtn.addEventListener('click', async () => {
    const user = auth.currentUser;
    if(user){
      // if already signed in, open app and show correct view
      me = user;
      await postLoginSetup();
      closeModal();
    } else {
      openModal();
    }
  });

  // login modal buttons
  loginClose.addEventListener('click', closeModal);

  loginBtn.addEventListener('click', async ()=>{
    const email = emailInput.value.trim();
    const pw = passInput.value;
    const remember = rememberMe.checked;
    if(!email || !pw) return alert('Enter email & password');
    await setPersistence(remember);
    try{
      const cred = await auth.signInWithEmailAndPassword(email, pw);
      me = cred.user;
      await postLoginSetup();
      closeModal();
    } catch(e){ alert('Sign-in failed: ' + e.message); }
  });

  openLogin.addEventListener('click', openModal);

  // sign out
  signOutBtn.addEventListener('click', async () => {
    try{
      if(convsUnsub) convsUnsub();
      if(msgsUnsub) msgsUnsub();
      if(myConvUnsub) myConvUnsub();
      await auth.signOut();
      me = null;
      myRole = 'guest';
      currentConversationId = null;
      messagesEl.innerHTML = '';
      hideApp();
      topUserInfo.textContent = 'Not signed in';
      // update floating badge visibility based on nothing
      openChatBadge.style.display = 'none';
      openChatBtn.style.display = 'flex';
    }catch(e){ console.warn(e); }
  });

  // post login: setup role and UI
  async function postLoginSetup(){
    // ensure users doc exists and determine role
    const doc = await db.collection('users').doc(me.uid).get();
    myRole = doc.exists ? doc.data().role || 'user' : 'user';
    if(!doc.exists){
      await db.collection('users').doc(me.uid).set({ role: myRole, email: me.email || null }, { merge:true });
    } else {
      if(me.email) await db.collection('users').doc(me.uid).set({ email: me.email }, { merge:true });
    }

    // show UI
    showApp();
    openChatBtn.style.display = 'none';
    topUserInfo.textContent = me.email ? (me.email + (myRole==='admin' ? ' â€¢ admin' : '')) : ('User â€¢ ' + me.uid.slice(0,6));
    signOutBtn.style.display = 'inline-block';
    document.getElementById('openLogin').style.display = 'none';

    if(myRole === 'admin'){
      chatTitle.textContent = 'Admin Inbox';
      chatSubtitle.textContent = 'Open any user to reply privately';
      startAdminView();
      // hide user's own chat view until admin opens a conversation
      messagesEl.innerHTML = '';
    } else {
      chatTitle.textContent = 'Your Private Chat';
      chatSubtitle.textContent = 'Only you and model see this.';
      startUserView();
    }

    // listen for conversation doc to set user's badge (unread from admin)
    if(myRole !== 'admin'){
      db.collection('conversations').doc(me.uid).onSnapshot(s => {
        const data = s.exists ? s.data() : {};
        const unread = data.unreadFromAdmin || 0;
        if(unread > 0){
          openChatBadge.style.display = 'block';
          openChatBadge.textContent = unread;
        } else {
          openChatBadge.style.display = 'none';
        }
      });
    }
  }

  // ---------- USER flow ----------
  function startUserView(){
    currentConversationId = me.uid;
    // when user opens chat, reset unreadFromAdmin to 0
    db.collection('conversations').doc(me.uid).set({ unreadFromAdmin: 0 }, { merge:true });
    subscribeUserMessages(me.uid);
  }

  function subscribeUserMessages(uid){
    if(myConvUnsub) myConvUnsub();
    myConvUnsub = db.collection('messages').doc(uid).collection('items').orderBy('timestamp','asc')
      .onSnapshot(snapshot => {
        const arr = [];
        snapshot.forEach(d => arr.push({ id: d.id, ...d.data() }));
        renderMessages(arr, me.uid);
        messagesEl.scrollTop = messagesEl.scrollHeight;
      });
  }

  // when user sends a message
  sendBtn.addEventListener('click', async () => {
    const text = textInput.value.trim();
    const file = fileInput.files[0];
    if(!text && !file) return;
    if(myRole === 'admin'){
      if(!currentConversationId) return alert('Open a user to reply');
      await adminSendReply(currentConversationId, text, file);
    } else {
      await userSendMessage(me.uid, text, file);
    }
    textInput.value = '';
    fileInput.value = '';
  });

  // Enter to send
  textInput.addEventListener('keydown', (e) => { if(e.key === 'Enter') sendBtn.click(); });

  async function uploadFile(file){
    if(!file) return { url:'', type:'' };
    const path = `chat/${Date.now()}_${file.name.replace(/\s+/g,'_')}`;
    const ref = storage.ref(path);
    await ref.put(file);
    const url = await ref.getDownloadURL();
    return { url, type: file.type || '' };
  }

  async function userSendMessage(convUid, text, file){
    const { url, type } = file ? await uploadFile(file) : { url:'', type:'' };
    await db.collection('messages').doc(convUid).collection('items').add({
      from: me.uid,
      fromName: me.email || ('User-'+me.uid.slice(0,6)),
      text: text || '',
      mediaUrl: url || null,
      mediaType: type || null,
      timestamp: serverTimestamp()
    });
    // increment unreadFromUser for admin and set lastMessage/lastTimestamp
    await db.collection('conversations').doc(convUid).set({
      lastMessage: text || (url ? 'Media' : ''),
      lastTimestamp: serverTimestamp(),
      unreadFromUser: FieldValue.increment(1)
    }, { merge:true });

    // ensure user's users/{uid} doc exists
    await db.collection('users').doc(convUid).set({ role:'user', email: me.email || null }, { merge:true });
  }

  // ---------- ADMIN flow ----------
  function startAdminView(){
    // subscribe to conversations collection and render sorted list
    if(convsUnsub) convsUnsub();
    convsUnsub = db.collection('conversations').onSnapshot(snap => {
      const rows = [];
      snap.forEach(d => rows.push({ id: d.id, ...d.data() }));
      rows.forEach(r => { r.unreadFromUser = r.unreadFromUser || 0; r.lastTimestamp = r.lastTimestamp || null; });
      rows.sort((a,b) => {
        if((b.unreadFromUser||0) - (a.unreadFromUser||0) !== 0) return (b.unreadFromUser||0) - (a.unreadFromUser||0);
        const ta = a.lastTimestamp ? (a.lastTimestamp.toMillis ? a.lastTimestamp.toMillis() : new Date(a.lastTimestamp).getTime()) : 0;
        const tb = b.lastTimestamp ? (b.lastTimestamp.toMillis ? b.lastTimestamp.toMillis() : new Date(b.lastTimestamp).getTime()) : 0;
        return tb - ta;
      });
      renderConversations(rows);
    });
  }

  function renderConversations(rows){
    conversationsList.innerHTML = '';
    rows.forEach(r => {
      const left = el('div', { className:'meta' },
        el('div', { className:'avatar' }, (r.id||'U').slice(0,2).toUpperCase()),
        el('div', null, el('div', { className:'name' }, r.displayName || r.id), el('div', { className:'last' }, r.lastMessage || ''))
      );
      const right = el('div', null, r.unreadFromUser ? el('div', { className:'badge' }, String(r.unreadFromUser)) : '');
      const row = el('div', { className:'conv' });
      row.appendChild(left); row.appendChild(right);
      row.addEventListener('click', () => openConversationAsAdmin(r.id, r.displayName));
      conversationsList.appendChild(row);
    });
  }

  async function openConversationAsAdmin(userUid, displayName){
    currentConversationId = userUid;
    chatTitle.textContent = displayName || ('User ' + userUid.slice(0,6));
    chatSubtitle.textContent = 'Private conversation';
    // subscribe to messages for this user
    if(msgsUnsub) msgsUnsub();
    msgsUnsub = db.collection('messages').doc(userUid).collection('items').orderBy('timestamp','asc').onSnapshot(snap => {
      const arr = [];
      snap.forEach(d => arr.push({ id: d.id, ...d.data() }));
      renderMessages(arr, me.uid);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    });
    // reset unreadFromUser to 0
    await db.collection('conversations').doc(userUid).set({ unreadFromUser: 0 }, { merge:true });
  }

  async function adminSendReply(userUid, text, file){
    const { url, type } = file ? await uploadFile(file) : { url:'', type:'' };
    await db.collection('messages').doc(userUid).collection('items').add({
      from: me.uid,
      fromName: me.email || 'Model',
      text: text || '',
      mediaUrl: url || null,
      mediaType: type || null,
      timestamp: serverTimestamp()
    });
    // increment unreadFromAdmin for user and set lastMessage/lastTimestamp
    await db.collection('conversations').doc(userUid).set({
      lastMessage: text || (url ? 'Media' : ''),
      lastTimestamp: serverTimestamp(),
      unreadFromAdmin: FieldValue.increment(1)
    }, { merge:true });
  }

  // render messages (safe DOM)
  function renderMessages(items, myUid){
    messagesEl.innerHTML = '';
    items.forEach(m => {
      const isSelf = (myRole === 'admin') ? (m.from === me.uid) : (m.from === myUid);
      const wrapper = el('div', { className: 'msg ' + (isSelf ? 'self' : 'other') });
      if(m.text) wrapper.appendChild(document.createTextNode(m.text));
      if(m.mediaUrl){
        if(m.mediaType && m.mediaType.startsWith('video/')){
          const v = document.createElement('video'); v.controls = true; v.src = m.mediaUrl; v.style.maxWidth = '100%'; wrapper.appendChild(v);
        } else {
          const img = document.createElement('img'); img.src = m.mediaUrl; img.alt = 'media'; img.style.maxWidth = '100%'; wrapper.appendChild(img);
        }
      }
      const metaText = (m.fromName ? m.fromName : (m.from ? m.from.slice(0,6) : '')) + (m.timestamp ? ' â€¢ ' + fmtTime(m.timestamp) : '');
      wrapper.appendChild(el('small', {}, metaText));

      // admin moderation: delete message button
      if(myRole === 'admin' && m.id){
        const del = el('button', { className:'ghost', title:'Delete', style:'margin-left:8px' }, 'ðŸ—‘');
        del.onclick = async () => {
          try{ await db.collection('messages').doc(currentConversationId).collection('items').doc(m.id).delete(); }
          catch(e){ console.warn(e); }
        };
        wrapper.appendChild(del);
      }

      messagesEl.appendChild(wrapper);
    });
  }

  // unsubscribe on unload
  window.addEventListener('beforeunload', () => {
    if(convsUnsub) convsUnsub();
    if(msgsUnsub) msgsUnsub();
    if(myConvUnsub) myConvUnsub();
  });

  // auth state persistence: detect logged in user on load
  auth.onAuthStateChanged(async user => {
    if(!user) {
      // not signed in
      hideApp();
      openChatBtn.style.display = 'flex';
      topUserInfo.textContent = 'Not signed in';
      return;
    }
    me = user;
    await postLoginSetup();
  });

  // keyboard accessibility: open login via Enter on openLogin
  document.addEventListener('keydown', (e) => {
    if(e.key === 'l' && e.ctrlKey){ openModal(); } // dev shortcut Ctrl+L
  });

  // tiny UI: toggle sidebar on small screens
  document.addEventListener('click', (e) => {
    if(window.innerWidth <= 900 && !sidebar.contains(e.target) && !toggleSidebar.contains(e.target) && sidebar.classList.contains('open')){
      sidebar.classList.remove('open');
    }
  });

  // Done
})();
</script>
</body>
</html>
